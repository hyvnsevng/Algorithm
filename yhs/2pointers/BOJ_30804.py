# 백준 30804번 과일 탕후루

# 탕후루에 꽂힌 과일의 종류가 배열로 주어질 때, 막대의 앞과 뒤에서 과일을 몇개씩 빼서 두 종류의 과일만 남게 하려고 한다.
# 이 때 탕후루의 최대 길이를 구하는 문제

# 투 포인터 알고리즘을 이용해 풀이했다.
# 처음엔 start, end 포인터를 하나씩 더해가며 계산하려 했으나 시간초과 발생
# 그래서 2차원 배열에 두 종류 과일의 정수와, 그 마지막 인덱스를 저장
# 과일 종류가 3가지가 되면 마지막 인덱스가 더 작은 과일의 종류를 새 과일로 대체하고, start 포인터를 (삭제된 과일의 마지막 인덱스 + 1)로 갱신

# 이 로직을 초기에 과일이 한 종류일 때와 동일하게 적용하려니 초기값과 조건 설정에 오류가 있었다.
# 1. 과일이 한 종류인 상태에서 새로운 종류의 과일을 만났을 때, 탕후루가 두가지 과일로 이루어져 문제가 없음에도 start를 갱신하는 오류를 범했다.
#    따라서 두 과일의 마지막 index를 저장하는 배열의 초기값을 [0, 0]이 아닌 [0, -1]로 바꾸어 해결했다.
#    이렇게 하면 첫 두 과일이 같은 종류이고 다음에 새로운 과일이 등장할 경우, start는 여전히 0이 되고 과일의 종류와 인덱스는 문제없이 갱신할 수 있다.
#              첫 두 과일이 같은 종류이고 끝까지 새로운 과일이 등장하지 않으면 매 반복마다 end만 1씩 늘려가며 길이를 갱신하여 답을 얻을 수 있다.
#              첫 두 과일이 다른 종류일 경우 start는 여전히 0이 되고 다른 두 과일의 정보를 2차원 배열에 갱신하여 초기 상태를 설정할 수 있다.
# 2. 과일의 종류가 바뀌지 않을 경우 마지막 인덱스를 갱신할 때, 초기에 인덱스가 0인 과일이 아닌 인덱스가 -1인 과일을 대체하는 오류를 범했다.
#    위의 경우, 1에서 start를 갱신하지 않으려 설정해둔 것이 의미가 없어져 연산이 제대로 이루어지지 않는다.
#    따라서 인덱스가 0인 과일을 대체하는 것으로 코드를 수정했다.
# 3. 탕후루의 길이는 절대 0이 될 수 없으나 길이의 초기값을 0으로 설정하는 오류를 범했고, 탕후루의 길이를 나타내는 numFruit의 초기값을 1로 바꿔 해결했다.

n = int(input())
fruits = list(map(int, input().split()))

start, end = 0, 1
numFruit = 1
fruitNindex = [[fruits[0], fruits[0]], [0, -1]]  # 과일 종류, 해당 과일 마지막 인덱스

while end < n:
    # 과일 종류 갱신하기
    if fruits[end] not in fruitNindex[0]:
        if fruitNindex[1][0] < fruitNindex[1][1]:
            fruitNindex[0][0] = fruits[end]
            start = fruitNindex[1][0] + 1
            fruitNindex[1][0] = end
        else:
            fruitNindex[0][1] = fruits[end]
            start = fruitNindex[1][1] + 1
            fruitNindex[1][1] = end

    # 과일 최후 인덱스 갱신하기
    else:
        if fruits[end] == fruitNindex[0][0]:
            fruitNindex[1][0] = end
        else:
            fruitNindex[1][1] = end

    if end - start + 1 > numFruit:
        numFruit = end - start + 1
    end += 1

print(numFruit)
